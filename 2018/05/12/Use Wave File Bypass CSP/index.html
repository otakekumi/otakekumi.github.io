<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><title>Use Wave File Bypass CSP [ 梅子酒の笔记本 ]</title><link rel="stylesheet" href="/css/meizj.css"><link rel="stylesheet" href="/css/prettify.css"><link rel="stylesheet" href="/css/tomorrow-night-blue.css"><link rel="stylesheet" href="/css/screen.css"><link rel="stylesheet" href="/css/tag.css"><script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.min.js"></script><script src="https://cdn.bootcss.com/lazysizes/5.1.0/lazysizes.min.js"></script><script>$("img").attr({"class":"lazyload"});



</script></head><body><div id="menu-outer"><nav id="menu-inner"><a id="menuLabel" href="/">Home</a><a id="menuLabel" href="/about">About</a><a id="menuLabel" href="/archives">Archives</a><a id="menuLabel" href="https://github.com/meizjm3i">Github</a></nav></div><div id="content-outer"><div id="content-inner"><div id="recent-posts"><a id="blogTitle">Meizj's Blog</a></div><article id="post"><h1 id="postTitle">Use Wave File Bypass CSP</h1><h2 id="csp-introduction"><a class="markdownIt-Anchor" href="#csp-introduction"></a> CSP Introduction</h2>
<p>CSP全称Content Security Policy，即内容安全策略。CSP是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括XSS和注入。</p>
<p>CSP被设计为完全向后兼容，在不同的浏览器上，不会因是否支持CSP而产生冲突问题。在不进行特定设置之前，默认为网页使用标准的同源策略。</p>
<p>通常可以使用meta标签来设置CSP，或者使用php的header函数来进行相关属性的设置。</p>
<p>CSP的配置会直接影响到页面加载资源的方式，在适当配置的情况下，可以有效的防范XSS攻击。</p>
<h2 id="csp-configuration"><a class="markdownIt-Anchor" href="#csp-configuration"></a> CSP Configuration</h2>
<p>我们通过Content-Security-Policy头信息来进行CSP的设置，通常格式如下:</p>
<blockquote>
<p>Content-Security-Policy: policy</p>
</blockquote>
<p>其中，policy部分对应的为具体的内容安全策略。</p>
<p>一个策略由一系列的策略指令组成，每个策略都描述了一个针对某个特定类型资源以及生效范围的策略。</p>
<p>网上对于相关指令和资源表的说明已经很多了，我就不再赘述。</p>
<h2 id="bypass-csp-with-different-policy"><a class="markdownIt-Anchor" href="#bypass-csp-with-different-policy"></a> Bypass CSP With Different Policy</h2>
<h3 id="common-policy-bypass"><a class="markdownIt-Anchor" href="#common-policy-bypass"></a> Common Policy Bypass</h3>
<p>目前在比赛中常见的绕过CSP一般是:</p>
<blockquote>
<p>script-src ‘self’ ‘unsafe-inline’<br>
script-src ‘self’ ‘unsafe-eval’<br>
script-src ‘nonce-*****’</p>
</blockquote>
<p>通常情况下，除了CSP之外，还都会搭配一定的过滤措施来让选手进行绕过。</p>
<p>这里有几个例子，我就不再多说：</p>
<ol>
<li>0CTF 2018 h4x0rs.club2 writeup</li>
</ol>
<blockquote>
<p><a href="http://sec2hack.com/ctf/0ctf2018-h4x0rs-club2.html" target="_blank" rel="noopener">http://sec2hack.com/ctf/0ctf2018-h4x0rs-club2.html</a></p>
</blockquote>
<ol start="2">
<li>Google CTF 2016 Wallowing Wallabies - Part Three</li>
</ol>
<blockquote>
<p><a href="http://countersite.org/articles/web-vulnerability/83-web-writeup-googlectf-wallowing-wallabies.html" target="_blank" rel="noopener">http://countersite.org/articles/web-vulnerability/83-web-writeup-googlectf-wallowing-wallabies.html</a></p>
</blockquote>
<h3 id="bypass-script-src-self"><a class="markdownIt-Anchor" href="#bypass-script-src-self"></a> Bypass &quot;script-src ‘self’ &quot;</h3>
<p>在前几天的PlaidCTF中，出现了如下的CSP:</p>
<blockquote>
<p>Content-Security-Policy: style-src ‘self’ <a href="https://fonts.googleapis.com" target="_blank" rel="noopener">https://fonts.googleapis.com</a>; font-src ‘self’ <a href="https://fonts.gstatic.com" target="_blank" rel="noopener">https://fonts.gstatic.com</a>; media-src ‘self’ blob:; script-src ‘self’; object-src ‘self’; frame-src ‘self’</p>
</blockquote>
<p>script-src 'self’代表着只能加载符合同源策略的文件，直接插入至html页面中的静态script标签将无法执行。结合其他CSP来看，常用的iframe，object等标签也是无法被绕过的。</p>
<p>我尝试着使用link的预加载机制去带出cookie，然而受限于script-src 'self’的限制，虽然能够通过dns带出信息，但是无法将cookie带出来，因此预加载也是无法使用的。</p>
<p>于是只能另外寻找突破口，在查阅大量资料后发现，可以通过引入正常的非js文件来达到引入js脚本的效果。考虑到题目中具有上传点，可以将js代码插入到尾部来进行绕过。</p>
<p>本地搭建环境进行测试：</p>
<p>xss.html内容为：<br>
<img src="https://s2.ax1x.com/2019/06/27/Zn5mxs.png" alt></p>
<p>cc.wave内容为：<br>
<img src="https://s2.ax1x.com/2019/06/27/Zn5e2j.png" alt></p>
<p>执行效果为:<br>
<img src="https://s2.ax1x.com/2019/06/27/Zn5Mq0.png" alt></p>
<p>可以看到注释部分并未对js的执行起到干扰，因此这种攻击手法是可行的。</p>
<p>在进行上传时，后端会进行文件格式校验，因此需要在保证文件格式验证正确的情况进行绕过，在录音选项中，上传的文件为webm格式，文件头是不可见字符，在引入js文件时，会产生错误，因此需要引入文件的文件头是可见字符。</p>
<p>这里对比下两者的文件格式便很明显了:<br>
<img src="https://s2.ax1x.com/2019/06/27/Zn5uMn.png" alt></p>
<p><img src="https://s2.ax1x.com/2019/06/27/Zn5Krq.png" alt></p>
<p>wav格式的文件是以RIFF明文开头的，可以使用我上面所用到的攻击方法去构造xss代码，而webm开头为乱码，在执行时，会因为产生报错而中止执行。<br>
在绕过文件格式检查之后，js会根据文件格式给定一个MIME-TYPE，在带入src属性的时候，audio的Type会和可执行脚本产生冲突，因此wav文件无法代入，而wave在MIME转换的名单之外，因此在上传成功wave文件时，其MIME-TYPE并不会与src冲突。<br>
因此直接在description中写入:</p>
<blockquote>
<script src="https://idiot.chal.pwning.xxx/uploads/upload_5aee08ef0275e0.94993532.wave"></script>
</blockquote>
<p>即可拿到cookie作为idolt1登陆，接下来的就是审计js，上传wave文件动态添加xss代码即可。</p>
<p>Bypass文件格式的重点在于javascript在遇到”变量+运算符+变量”格式的表达式时，可以将注释插入其中，并且不会产生干扰。</p>
<p>在这个题目中，难点有两个：</p>
<ol>
<li>绕过self限制</li>
<li>构造出符合文件内容检查的文件</li>
</ol>
<p>同样的，我对于php是否会有此类特性也感到好奇，在经过测试后发现，在插入注释后，php的执行也不会被干扰。而python因为不具有行内注释的操作而无法做到上述操作。</p>
<p>之前看某篇paper，其中曾提到使用GIF绕过CSP，其中的部分思路和我上面用到的有部分相似。Paper链接如下：</p>
<blockquote>
<p><a href="https://www.slideshare.net/x00mario/jsmvcomfg-to-sternly-look-at-javascript-mvc-and-templating-frameworks/3-TodayJavaScript_MVC_Templating_FrameworksWhy_Because" target="_blank" rel="noopener">https://www.slideshare.net/x00mario/jsmvcomfg-to-sternly-look-at-javascript-mvc-and-templating-frameworks/3-TodayJavaScript_MVC_Templating_FrameworksWhy_Because</a></p>
</blockquote>
<p>首先，同样是上传GIF，使得GIF与目标网站处于同源下，然后使用Angular的class去调用这个GIF文件，然后会生成script标签，并且其src属性是GIF文件，此时GIF中的内容被作为js代码解析了，并且因为处于同源情况下，因此可以顺利触发xss。</p>
<h3 id="comments-on-csp"><a class="markdownIt-Anchor" href="#comments-on-csp"></a> Comments On CSP</h3>
<p>CSP作为内容安全策略，在合理配置的情况，可以极大的提高xss的攻击成本，以达到较好的防御效果，然而部署成本同样较高，一是熟练掌握相关策略带来的难度，一是配置CSP所带来的工作量。</p>
<p>CSP的不当配置不仅会引发安全问题，还有可能导致页面资源加载失败，但总的来说，CSP仍然是防范XSS攻击较为优秀的措施。</p>
</article><div id="paginator"></div></div></div><div id="footer"><div id="bottom-inner"><span>Powerd By </span><span> Meizj </span><span>using    </span><a href="https://github.com/meizjm3i/Meizj"><span>Meizj</span></a><span>.</span><br></div></div><script src="/js/prettify.js"></script><script>//- $(window).on('load', function(){ 
$('pre').addClass('prettyprint linenums');
prettyPrint();
//- });
$(".gutter").remove();</script></body></html>