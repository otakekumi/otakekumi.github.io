<!DOCTYPE html>


  <html class="dark page-post">


<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>FastJson反序列化解析流程 | 梅子酒の笔记本</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="forsigner,前端,设计,Hexo主题,前端开发,用户体验,设计,frontend,design,nodejs,JavaScript">
  

  <meta name="description" content="前言 这是一篇炒冷饭性质的文章，距离FastJson的反序列化漏洞曝出已经过去了差不多两年的时间，网上相关的漏洞分析文章也是十分充足，但是我最近在阅读相关文章的时候发现普遍都是分析漏洞利用环节，许多解析部分的细节便不可得知。于是用了些时间分析了下其解析流程，也就有了本文。本篇内容主要为FastJson反序列化解析流程中涉及到的类及函数的分析。  整体调用栈   解析过程中的关键类 在用以调试的d">
<meta property="og:type" content="article">
<meta property="og:title" content="FastJson反序列化解析流程">
<meta property="og:url" content="https://meizjm3i.github.io/2019/06/05/FastJson反序列化解析流程/index.html">
<meta property="og:site_name" content="梅子酒の笔记本">
<meta property="og:description" content="前言 这是一篇炒冷饭性质的文章，距离FastJson的反序列化漏洞曝出已经过去了差不多两年的时间，网上相关的漏洞分析文章也是十分充足，但是我最近在阅读相关文章的时候发现普遍都是分析漏洞利用环节，许多解析部分的细节便不可得知。于是用了些时间分析了下其解析流程，也就有了本文。本篇内容主要为FastJson反序列化解析流程中涉及到的类及函数的分析。  整体调用栈   解析过程中的关键类 在用以调试的d">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://s2.ax1x.com/2019/06/27/ZnWPtH.jpg">
<meta property="og:image" content="https://s2.ax1x.com/2019/06/27/ZnWA1I.jpg">
<meta property="og:image" content="https://s2.ax1x.com/2019/06/27/ZnWEct.jpg">
<meta property="og:image" content="https://s2.ax1x.com/2019/06/27/ZnWMNQ.jpg">
<meta property="og:image" content="https://s2.ax1x.com/2019/06/27/ZnWQhj.jpg">
<meta property="og:image" content="https://s2.ax1x.com/2019/06/27/ZnW33n.jpg">
<meta property="og:image" content="https://s2.ax1x.com/2019/06/27/ZnWYuV.jpg">
<meta property="og:image" content="https://s2.ax1x.com/2019/06/27/ZnWNHU.jpg">
<meta property="og:updated_time" content="2019-06-27T07:17:15.002Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="FastJson反序列化解析流程">
<meta name="twitter:description" content="前言 这是一篇炒冷饭性质的文章，距离FastJson的反序列化漏洞曝出已经过去了差不多两年的时间，网上相关的漏洞分析文章也是十分充足，但是我最近在阅读相关文章的时候发现普遍都是分析漏洞利用环节，许多解析部分的细节便不可得知。于是用了些时间分析了下其解析流程，也就有了本文。本篇内容主要为FastJson反序列化解析流程中涉及到的类及函数的分析。  整体调用栈   解析过程中的关键类 在用以调试的d">
<meta name="twitter:image" content="https://s2.ax1x.com/2019/06/27/ZnWPtH.jpg">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-38189205-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?57e94d016e201fba3603a8a2b0263af0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  

</head>
</html>
<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">导航</span>
  

  <div class="post-header LEFT">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">导航</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
    </ul>
  </div>


</div>




<div class="content content-post LEFT">
   <article id="post-FastJson反序列化解析流程" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">FastJson反序列化解析流程</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2019.06.05</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Meizj</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </span>



      

      
      
    </div>
  </header>

  <div class="article-content">
    
      <h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>这是一篇炒冷饭性质的文章，距离FastJson的反序列化漏洞曝出已经过去了差不多两年的时间，网上相关的漏洞分析文章也是十分充足，但是我最近在阅读相关文章的时候发现普遍都是分析漏洞利用环节，许多解析部分的细节便不可得知。于是用了些时间分析了下其解析流程，也就有了本文。本篇内容主要为FastJson反序列化解析流程中涉及到的类及函数的分析。</p>
<h2 id="整体调用栈"><a class="markdownIt-Anchor" href="#整体调用栈"></a> 整体调用栈</h2>
<p><img src="https://s2.ax1x.com/2019/06/27/ZnWPtH.jpg" alt></p>
<h2 id="解析过程中的关键类"><a class="markdownIt-Anchor" href="#解析过程中的关键类"></a> 解析过程中的关键类</h2>
<p>在用以调试的demo中，处理JSON数据的语句为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSONObject obj = JSON.parseObject(data,Feature.SupportNonPublicField);</span><br></pre></td></tr></table></figure>
<p>整个JSON数据的处理也就是从<code>parseObject</code>这个函数开始。</p>
<h3 id="comalibabafastjsonparserdefaultjsonparser"><a class="markdownIt-Anchor" href="#comalibabafastjsonparserdefaultjsonparser"></a> com.alibaba.fastjson.parser.DefaultJSONParser</h3>
<p>从demo开始，进入的第一个类本应是<code>JSON</code>，但是因为JSON类并未进行关键操作，因此就采取忽略，转而关注在<code>com.alibaba.fastjson.JSON:74</code>处调用的DefaultJSONParser。</p>
<p>在DefaultJSONParser中，我们需要关注的函数有两个:</p>
<ul>
<li>parse</li>
<li>parseObject</li>
</ul>
<p>借助这两个函数，<code>DefaultJSONParser</code>完成了对于JSON数据的解析。</p>
<h3 id="comalibabafastjsonparserdeserializerfielddeserializer"><a class="markdownIt-Anchor" href="#comalibabafastjsonparserdeserializerfielddeserializer"></a> com.alibaba.fastjson.parser.deserializer.FieldDeserializer</h3>
<p>在Java反射中，可以通过Field获取某个类的属性或该属性的值，类<code>FieldDeserializer</code>用于存储字段所对应的反序列化器，FiledDeserializer会存储至ObjectDeserializer中，其中Key对应为字段名称。</p>
<p>在<code>FieldDeserializer</code>类中，主要由几类函数组成:</p>
<ul>
<li>构造函数</li>
<li>parseField</li>
<li>setValue</li>
<li>getFastMatchToken</li>
</ul>
<h3 id="comalibabafastjsonparserjavabeandeserializer"><a class="markdownIt-Anchor" href="#comalibabafastjsonparserjavabeandeserializer"></a> com.alibaba.fastjson.parser.JavaBeanDeserializer</h3>
<p><code>JavaBeanDeserializer</code>是一个反序列化器，也就是我们上面在<code>FieldDeserializer</code>中提到的&quot;反序列器&quot;。</p>
<p><code>JavaBeanDeserializer</code>在进行反序列化时，会接受如下参数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">deserialze</span><span class="params">(DefaultJSONParser parser, Type type, Object fieldName, Object object, <span class="keyword">int</span> features)</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.ax1x.com/2019/06/27/ZnWA1I.jpg" alt></p>
<h2 id="解析过程中的关键函数"><a class="markdownIt-Anchor" href="#解析过程中的关键函数"></a> 解析过程中的关键函数</h2>
<h3 id="comalibabafastjsonparserdefaultjsonparserparseobject"><a class="markdownIt-Anchor" href="#comalibabafastjsonparserdefaultjsonparserparseobject"></a> com.alibaba.fastjson.parser.DefaultJSONParser$parseObject</h3>
<p>在此函数中，<code>DefaultJSONParser</code>会完成对于JSON数据的处理，我们所追求的命令执行也是在这一步中实现。该函数的主体实现包裹在一个<code>while(True)</code>循环中，在这个while循环中，会不断取JSON数据中的下一个token(也就是字符)进行处理:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">    lexer.skipWhitespace();</span><br><span class="line">    <span class="keyword">char</span> ch = lexer.getCurrent(); <span class="comment">/* 比如 ch = '"' */</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>以下面这个demo为例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&#123;&quot;@type&quot;:&quot;...&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>会首先取出<code>name</code>添加至<code>SymbolTable</code>，再深入对<code>name</code>键对应的数据进行循环处理。</p>
<h3 id="comalibabafastjsonparserjsonlexerbasescansymbol"><a class="markdownIt-Anchor" href="#comalibabafastjsonparserjsonlexerbasescansymbol"></a> com.alibaba.fastjson.parser.JSONLexerBase$scanSymbol</h3>
<p><code>scanSymbol</code>主要调用点在刚才提到的parseObject中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key = lexer.scanSymbol(<span class="keyword">this</span>.symbolTable, <span class="string">'"'</span>);</span><br></pre></td></tr></table></figure>
<p>在<code>scanSymbol</code>函数中，会首先取出键，比如下面这个例子中的<code>name</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;...&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>在取出键之后，会调用<code>addSymbol</code>函数，将<code>name</code>这个键名添加至<code>SymbolTable</code>中:<br>
<img src="https://s2.ax1x.com/2019/06/27/ZnWEct.jpg" alt></p>
<h3 id="comalibabafastjsonparserparserconfigdeserialze"><a class="markdownIt-Anchor" href="#comalibabafastjsonparserparserconfigdeserialze"></a> com.alibaba.fastjson.parser.ParserConfig$deserialze</h3>
<p>谈及该函数，必然需要理解<code>ParserConfig</code>类，<code>ParserConfig</code>在反序列化的过程维护了常用类型和反序列化器的对应关系，并将该对应关系存放至<code>IdentityHashMap</code>。我们可以通过<code>getDeserializer</code>方法获得对象反序列化器<code>ObjectDeserializer</code>。</p>
<p>当出现未定义的类型时，则会在获取该类型的反序列化器的同时建立起对应关系，并存放至<code>IdentityHashMap</code>。为了更好地理解它，可以举一个例子:<code>ParserConfig$getDeserializer(Type type)</code>，我们可以分析其实现源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ObjectDeserializer derializer = (ObjectDeserializer)<span class="keyword">this</span>.derializers.get(type);</span><br><span class="line"><span class="keyword">if</span> (derializer != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> derializer;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getDeserializer((Class)type, type);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">    Type rawType = ((ParameterizedType)type).getRawType();</span><br><span class="line">    <span class="keyword">return</span> rawType <span class="keyword">instanceof</span> Class ? <span class="keyword">this</span>.getDeserializer((Class)rawType, type) : <span class="keyword">this</span>.getDeserializer(rawType);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> JavaObjectDeserializer.instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数为获取ParserConfig中存储的反序列化器，当反序列化器存在时，则直接将其返回，不存在时则调用<code>getDeserializer(Class&lt;?&gt; clazz, Type type)</code>，获取类与反序列器的对应关系，并在最后存入<code>IdentityHashMap</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.putDeserializer((Type)type, (ObjectDeserializer)derializer);</span><br></pre></td></tr></table></figure>
<h3 id="parsefield"><a class="markdownIt-Anchor" href="#parsefield"></a> parseField</h3>
<p>由于该函数存在重名实现，因此以序号分开。</p>
<ol>
<li>com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer$parseField</li>
<li>com.alibaba.fastjson.parser.deserializer.DefaultFieldDeserializer$parseField</li>
</ol>
<p>虽然上述的两个函数重名，然而在一般情况下，<code>DefaultFieldDeserializer$parseField</code>在<code>JavaBeanDeserializer$parseField</code>中被调用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">            lexer.nextTokenWithColon(((FieldDeserializer)fieldDeserializer).getFastMatchToken());</span><br><span class="line">    ((FieldDeserializer)fieldDeserializer).parseField(parser, object, objectType, fieldValues);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>JavaBeanDeserializer$parseField</code>中，当检测到存在与传入的Key所匹配的反序列化器时，便会调用<code>DefaultFieldDeserializer$parseField</code>进行反序列化。</p>
<p>当进入<code>DefaultFieldDeserializer$parseField</code>时，我们可以看到<code>this</code>中已经存在<code>fieldValueDeserializer</code>了:<br>
<img src="https://s2.ax1x.com/2019/06/27/ZnWMNQ.jpg" alt></p>
<p>随后调用对应的反序列化器，这里以我图中为例:<br>
<img src="https://s2.ax1x.com/2019/06/27/ZnWQhj.jpg" alt><br>
对应的语句为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = <span class="keyword">this</span>.fieldValueDeserilizer.deserialze(parser, fieldType, <span class="keyword">this</span>.fieldInfo.name);</span><br></pre></td></tr></table></figure>
<h3 id="comalibabafastjsonparserdeserializerfielddeserializersetvalue"><a class="markdownIt-Anchor" href="#comalibabafastjsonparserdeserializerfielddeserializersetvalue"></a> com.alibaba.fastjson.parser.deserializer.FieldDeserializer$setValue</h3>
<p><code>setValue</code>接受两个传参:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object object, Object value)</span></span></span><br></pre></td></tr></table></figure>
<p><code>object</code>为类对象，<code>value</code>为属性值。<br>
<img src="https://s2.ax1x.com/2019/06/27/ZnW33n.jpg" alt></p>
<p>在<code>setValue</code>中会进行字段的赋值操作，对object的get方法进行触发，当检测到method返回的类型与Map类型一致时，则会进一步触发反射，完成RCE，关键代码如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (Map.class.isAssignableFrom(method.getReturnType())) &#123;</span><br><span class="line">    Map map = (Map)method.invoke(object);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        map.putAll((Map)value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>method</code>为:<br>
<img src="https://s2.ax1x.com/2019/06/27/ZnWYuV.jpg" alt></p>
<h3 id="comalibabafastjsonutiljavabeaninfojavabeaninfobuild"><a class="markdownIt-Anchor" href="#comalibabafastjsonutiljavabeaninfojavabeaninfobuild"></a> com.alibaba.fastjson.util.JavaBeanInfo.JavaBeanInfo$build</h3>
<p><code>build</code>函数接受三个参数传入:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JavaBeanInfo <span class="title">build</span><span class="params">(Class&lt;?&gt; clazz, Type type, PropertyNamingStrategy propertyNamingStrategy)</span></span></span><br></pre></td></tr></table></figure>
<p>在<code>build</code>函数中，通过反射获得传入参数的<code>clazz</code>类及父类的所有方法，随后遍历这些方法，将其中的set方法以及get方法取出，如图中<code>fields</code>所示:<br>
<img src="https://s2.ax1x.com/2019/06/27/ZnWNHU.jpg" alt></p>
<p>其中，<code>beanInfo</code>的生成的语句为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanInfo = JavaBeanInfo.build(clazz, type, <span class="keyword">this</span>.propertyNamingStrategy);</span><br></pre></td></tr></table></figure>
<h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2>
<ul>
<li><a href="https://paper.seebug.org/636/" target="_blank" rel="noopener">FastJson 反序列化漏洞利用的三个细节 - TemplatesImpl 利用链</a></li>
<li><a href="http://xxlegend.com/2017/04/29/title-%20fastjson%20%E8%BF%9C%E7%A8%8B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96poc%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">fastjson 远程反序列化poc的构造和分析</a></li>
<li><a href="https://www.oschina.net/question/54100_25366" target="_blank" rel="noopener">FastJson技术内幕</a></li>
<li><a href="https://paper.seebug.org/916/#addcharacter" target="_blank" rel="noopener">XMLDecoder解析流程分析</a></li>
<li><a href="https://github.com/shengqi158/fastjson-remote-code-execute-poc/blob/master/Java_JSON%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8B%E6%AE%87_%E7%9C%8B%E9%9B%AA%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91%E8%80%85%E5%B3%B0%E4%BC%9A.pdf" target="_blank" rel="noopener">Java Json反序列化之殇</a></li>
</ul>

    
  </div>

</article>


   

   



</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
